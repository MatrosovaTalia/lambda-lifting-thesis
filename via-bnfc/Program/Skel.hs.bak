-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Program.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Program.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: Program.Abs.Ident -> Result
transIdent x = case x of
  Program.Abs.Ident string -> failure x

transProgram :: Program.Abs.Program -> Result
transProgram x = case x of
  Program.Abs.Program decls -> failure x

transRoutineDecl :: Program.Abs.RoutineDecl -> Result
transRoutineDecl x = case x of
  Program.Abs.RoutineDecl ident idents decls -> failure x

transDecl :: Program.Abs.Decl -> Result
transDecl x = case x of
  Program.Abs.DeclReturn expr -> failure x
  Program.Abs.DeclStatement statement -> failure x
  Program.Abs.DeclDef routinedecl -> failure x

transStatement :: Program.Abs.Statement -> Result
transStatement x = case x of
  Program.Abs.Assign ident expr -> failure x
  Program.Abs.RoutineCall ident exprs -> failure x
  Program.Abs.WhileLoop expr decls -> failure x
  Program.Abs.ForLoop ident expr1 expr2 decls -> failure x
  Program.Abs.If expr decls -> failure x
  Program.Abs.IfElse expr decls1 decls2 -> failure x
  Program.Abs.Print expr -> failure x

transExpr :: Program.Abs.Expr -> Result
transExpr x = case x of
  Program.Abs.EInt integer -> failure x
  Program.Abs.EVar ident -> failure x
  Program.Abs.ENot expr -> failure x
  Program.Abs.ETimes expr1 expr2 -> failure x
  Program.Abs.EDiv expr1 expr2 -> failure x
  Program.Abs.ERem expr1 expr2 -> failure x
  Program.Abs.EPlus expr1 expr2 -> failure x
  Program.Abs.EMinus expr1 expr2 -> failure x
  Program.Abs.EAND expr1 expr2 -> failure x
  Program.Abs.EOR expr1 expr2 -> failure x
  Program.Abs.EXOR expr1 expr2 -> failure x
